//Callback functions for UI elements
/// <reference path="bulkOperations.js" />
/// <reference path="commonElements.js" />
/// <reference path="keyFormatters.js" />
/// <reference path="main.js" />
/// <reference path="pageGenerators.js" />
/// <reference path="selectionFunctions.js" />
/// <reference path="sortFunctions.js" />
/// <reference path="tableMakers.js" />
/// <reference path="templateFillers.js" />
/// <reference path="wikiAPI.js" />

function tableChanged(event) {
    let masterID = parseInt(event.currentTarget.selectedOptions[0].value);
    try {
        wikiTableOutput.textContent = masterTable[masterID].generate();
    } catch (error) {
        console.error(error);
    }
}

function itemChanged(event) {
    let itemID = parseInt(event.currentTarget.selectedOptions[0].value);
    try {
        wikiTableOutput.textContent = createItemPageContent(itemID);
    } catch (error) {
        console.error(error);
    }
}

function loginButton() {
    document.getElementById('wikiLogin').style.display = '';
}

async function buttonRequestPage() {
    //let pageContent = getFullWikiPage('Chest of Witwix');
    try {
        let pageContent = await getFullWikiPage('Chest of Witwix');
        console.log(pageContent);
        let itemTemplate = pageContent.match(ITEMTEMPLATEREGEX);
        console.log(itemTemplate);
        wikiTableOutput.textContent = pageContent;
        /*
        let pageSectionID = await getSectionID('Chest of Witwix', 'Loot Table');
        console.log(pageSectionID);
        let pageContent = await getWikiPageSection('Chest of Witwix', pageSectionID);
        */
    } catch (e) {
        console.error(e);
    }
}

function loginCancel() {
    document.getElementById('wikiLogin').style.display = 'none';
}

async function trueLogin() {
    console.log('Logging In...');
    let logintoken = await getLoginToken();
    getLoginRequest(logintoken, document.getElementById('wikiUserInput').value, document.getElementById('wikiPassInput').value);
}

async function logoutButton() {
    console.log('Logging Out...');
    let csrftoken = await getCsrfToken();
    getLogoutRequest(csrftoken);
}

async function buttonImageUploadURL() {
    console.log('Attempting Image Upload From URL')
    let csrftoken = await getCsrfToken();
    uploadImageFromUrl('Slayer Coins.svg', 'Automatically uploaded by coolbot95.', 'https://melvoridle.com/assets/media/main/slayer_coins.svg', csrftoken)
}

async function buttonImageUploadBlob() {
    console.log('Attempting Image Upload From Blob')
    let csrftoken = await getCsrfToken();
    let imageURL = GAMEURL + 'assets/media/shop/equipment_set.svg';
    let response = await uploadImageFromUrlViaBlob('Equipment Set (upgrade).svg', '[[Category:Upgrades]]', imageURL, csrftoken);
    console.log(response);
}

async function uploadTestItemPage(itemID) {
    console.log('Attempting to create item test Page')
    if (wikiDataLoaded) {
        let csrftoken = await getCsrfToken();
        let response = await createWikiPage(items[itemID].name, createItemPageContent(itemID), 'Page autogenerated by coolbot95. This is a test.', csrftoken)
        console.log(response);
    } else {
        console.error('Wiki Data has not loaded.')
    }
}

function uploadDungeonImages() {
    if (wikiDataLoaded) {
        //Generate image sources and filenames
        let dungeonImageSources = [];
        let dungeonImageFilenames = [];
        for (let i = 0; i < DUNGEONS.length; i++) {
            dungeonImageSources.push(GAMEURL + DUNGEONS[i].media);
            dungeonImageFilenames.push(`${DUNGEONS[i].name} (dungeon).svg`);
        }
        bulkUploadImages(dungeonImageFilenames, dungeonImageSources, '[[Category:Dungeons]]');
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function uploadPrayerImages() {
    if (wikiDataLoaded) {
        //Generate image sources and filenames
        let prayerImageSources = [];
        let prayerImageFilenames = [];
        for (let i = 0; i < PRAYER.length; i++) {
            prayerImageSources.push(GAMEURL + PRAYER[i].media);
            prayerImageFilenames.push(`${PRAYER[i].name} (prayer).svg`);
        }
        bulkUploadImages(prayerImageFilenames, prayerImageSources, '[[Category:Prayers]]');
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function uploadItemImages() {
    if (wikiDataLoaded) {
        //Generate image sources and filenames
        let itemImageSources = [];
        let itemImageFilenames = [];
        for (let i = 0; i < items.length; i++) {
            itemImageSources.push(GAMEURL + items[i].media);
            itemImageFilenames.push(`${items[i].name} (item)${getFileExtension(items[i].media)}`);
        }
        bulkUploadImages(itemImageFilenames, itemImageSources, '[[Category:Items]]');
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function uploadNewItemImages(startIndex) {
    if (wikiDataLoaded) {
        //Generate image sources and filenames
        let itemImageSources = [];
        let itemImageFilenames = [];
        for (let i = startIndex; i < items.length; i++) {
            itemImageSources.push(GAMEURL + items[i].media);
            itemImageFilenames.push(`${items[i].name} (item)${getFileExtension(items[i].media)}`);
        }
        bulkUploadImages(itemImageFilenames, itemImageSources, '[[Category:Items]]');
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function createItemPages(startIndex) {
    if (wikiDataLoaded) {
        //Create item pages
        bulkCreateItemPages(startIndex, items.length - 1)
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function createMonsterPages(startIndex) {
    if (wikiDataLoaded) {
        //Create item pages
        bulkCreateMonsterPages(startIndex, MONSTERS.length - 1)
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function createCombatAreaPages(startIndex) {
    if (wikiDataLoaded) {
        //Create item pages
        bulkCreateCombatAreaPages(startIndex, combatAreas.length - 1)
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function createSlayerAreaPages(startIndex) {
    if (wikiDataLoaded) {
        //Create item pages
        bulkCreateSlayerAreaPages(startIndex, slayerAreas.length - 1)
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function createDungeonPages(startIndex) {
    if (wikiDataLoaded) {
        //Create item pages
        bulkCreateDungeonPages(startIndex, 8)
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function createSpellPages(startIndex) {
    if (wikiDataLoaded) {
        //Create item pages
        bulkCreateSpellPages(startIndex, SPELLS.length - 1)
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function createPrayerPages(startIndex) {
    if (wikiDataLoaded) {
        //Create item pages
        bulkCreatePrayerPages(startIndex, PRAYER.length - 1)
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function createThievingPages(startIndex) {
    if (wikiDataLoaded) {
        //Create item pages
        bulkCreateThievingPages(startIndex, thievingNPC.length - 1)
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function createUpgradePages() {
    if (wikiDataLoaded) {
        //Create item pages
        bulkCreateUpgradePages();
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function createTableTemplates() {
    if (wikiDataLoaded) {
        //Create table templates
        bulkCreateTableTemplates();
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function createItemSourceTemplates() {
    if (wikiDataLoaded) {
        //Create table templates
        bulkCreateItemSourceTemplates();
    } else {
        console.error('Wiki data is not loaded.')
    }
}


function uploadMonsterImages() {
    if (wikiDataLoaded) {
        let monstersOnList = [];
        for (let i = 0; i < MONSTERS.length; i++) {
            monstersOnList.push(false);
        }
        let monsterImageSources = [];
        let monsterImageFilenames = [];
        for (let i = 0; i < combatAreas.length; i++) {
            for (let j = 0; j < combatAreas[i].monsters.length; j++) {
                let monsterID = combatAreas[i].monsters[j];
                if (!monstersOnList[monsterID] && !isItemOnArray(`${MONSTERS[monsterID].name} (monster).svg`, monsterImageFilenames)) {
                    monstersOnList[monsterID] = true;
                    monsterImageSources.push(GAMEURL + MONSTERS[monsterID].media);
                    monsterImageFilenames.push(`${MONSTERS[monsterID].name} (monster).svg`);
                }
            }
        }
        for (let i = 0; i < DUNGEONS.length; i++) {
            for (let j = 0; j < DUNGEONS[i].monsters.length; j++) {
                let monsterID = DUNGEONS[i].monsters[j];
                if (!monstersOnList[monsterID] && !isItemOnArray(`${MONSTERS[monsterID].name} (monster).svg`, monsterImageFilenames)) {
                    monstersOnList[monsterID] = true;
                    monsterImageSources.push(GAMEURL + MONSTERS[monsterID].media);
                    monsterImageFilenames.push(`${MONSTERS[monsterID].name} (monster).svg`);
                }
            }
        }
        bulkUploadImages(monsterImageFilenames, monsterImageSources, '[[Category:Monsters]]');
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function uploadCombatAreaImages() {
    if (wikiDataLoaded) {
        //Generate image sources and filenames
        let areaImageSources = [];
        let areaImageFilenames = [];
        for (let i = 0; i < combatAreas.length; i++) {
            areaImageSources.push(GAMEURL + combatAreas[i].media);
            areaImageFilenames.push(`${combatAreas[i].areaName} (combatArea).svg`);
        }
        for (let i = 0; i < slayerAreas.length; i++) {
            areaImageSources.push(GAMEURL + slayerAreas[i].media);
            areaImageFilenames.push(`${slayerAreas[i].areaName} (combatArea).svg`);
        }
        bulkUploadImages(areaImageFilenames, areaImageSources, '[[Category:Combat Areas]]');
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function uploadSpellImages() {
    if (wikiDataLoaded) {
        let spellImageSources = [];
        let spellImageFilenames = [];
        for (let i = 0; i < SPELLS.length; i++) {
            spellImageSources.push(GAMEURL + SPELLS[i].media);
            spellImageFilenames.push(`${SPELLS[i].name} (spell).svg`);
        }
        bulkUploadImages(spellImageFilenames, spellImageSources, '[[Category:Spells]]');
    } else {
        console.error('Wiki data is not loaded.')
    }
}

function uploadUpgradeImages() {
    if (wikiDataLoaded) {
        let upgradeImageSources = [];
        let upgradeImageFilenames = [];
        //Bank Slot
        upgradeImageSources.push(GAMEURL + 'assets/media/main/bank_header.svg');
        upgradeImageFilenames.push('Bank Slot (upgrade).svg')
        //Multi Tree
        upgradeImageSources.push(GAMEURL + 'assets/media/shop/woodcutting_multi_tree.svg');
        upgradeImageFilenames.push('Multi-Tree (upgrade).svg')
        for (let i = 1; i < tiers.length; i++) {
            //Axes
            upgradeImageSources.push(GAMEURL + "assets/media/shop/axe_" + tiers[i] + ".svg");
            upgradeImageFilenames.push(`${setToUppercase(tiers[i])} Axe (upgrade).svg`)
            //Fishing Rods
            upgradeImageSources.push(GAMEURL + "assets/media/shop/fishing_" + tiers[i] + ".svg");
            upgradeImageFilenames.push(`${setToUppercase(tiers[i])} Fishing Rod (upgrade).svg`)
            //Cooking Fires
            upgradeImageSources.push(GAMEURL + "assets/media/shop/pickaxe_" + tiers[i] + ".svg");
            upgradeImageFilenames.push(`${setToUppercase(tiers[i])} Pickaxe (upgrade).svg`)
        }
        //Cooking fires
        for (let i = 0; i < cookingFireData.length; i++) {
            upgradeImageSources.push(GAMEURL + cookingFireData[i].media);
            upgradeImageFilenames.push(`${setToUppercase(cookingFireData[i].tier)} Cooking Fire (upgrade).svg`)
        }
        //Auto Eat
        for (let i = 0; i < autoEatData.length; i++) {
            upgradeImageSources.push(GAMEURL + 'assets/media/shop/autoeat.svg');
            upgradeImageFilenames.push(`${autoEatData[i].title} (upgrade).svg`)
        }
        for (let i = 0; i < godUpgradeData.length; i++) {
            upgradeImageSources.push(GAMEURL + godUpgradeData[i].media);
            upgradeImageFilenames.push(`${godUpgradeData[i].name} (upgrade).svg`)
        }
        bulkUploadImages(upgradeImageFilenames, upgradeImageSources, '[[Category:Upgrades]]');
    } else {
        console.error('Wiki data is not loaded.')
    }
}

async function updateItemPages() {
    if (wikiDataLoaded) {
        let pagesToEdit = [];
        for (let i = 803; i < items.length; i++) {
            let updateSuccess = true;
            let dataChanged = false;
            let pageName = wikiPageNames.items[i];
            let pullResult = await getFullWikiPage(pageName, 0);
            if (pullResult.success) {
                let oldItemPage = pullResult.text;
                //Replace Main Item Template
                let newItemPage = oldItemPage.replace(ITEMTEMPLATEREGEX, fillItemTemplate(i));
                //Replace Stats Templates
                if (items[i].equipmentSlot != undefined) {
                    if (items[i].equipmentSlot == CONSTANTS.equipmentSlot.Quiver && (items[i].ammoType == 2 || items[i].ammoType == 3)) {
                        newItemPage = newItemPage.replace(WEAPONSTATSREGEX, fillWeaponStatsTemplate(i));
                    } else if (items[i].equipmentSlot == CONSTANTS.equipmentSlot.Weapon) {
                        newItemPage = newItemPage.replace(WEAPONSTATSREGEX, fillWeaponStatsTemplate(i));
                    } else {
                        newItemPage = newItemPage.replace(ARMOURSTATSREGEX, fillArmourStatsTemplate(i));
                    }
                }
                if (newItemPage != oldItemPage) {
                    dataChanged = true;
                }
                //Check Loot Table Template for Changes:
                if (items[i].canOpen) {
                    let lootPullResult = await getFullWikiPage(`Template:${items[i].name}LootTable`, 0);
                    if (lootPullResult.success) {
                        let oldLootPage = lootPullResult.text;
                        let newLootPage = oldLootPage.replace(TABLEREGEX, createChestDropTable(i));
                        if (oldLootPage != newLootPage) {
                            dataChanged = true;
                        }
                    } else {
                        updateSuccess = false;
                        console.warn(`Cannot update page: ${pageName}. ${lootPullResult.error}`)
                    }
                }
                //Check Source Template for Changes:
                let sourcePullResult = await getFullWikiPage(`Template:${items[i].name} Sources`)
                if (sourcePullResult.success) {
                    let oldSourcePage = sourcePullResult.text;
                    oldSourcePage = oldSourcePage.replace(OLDVERSIONCATEGORYREGEX, VERSIONCATEGORY);
                    let newSourcePage = createItemSourceTemplatePage(i);
                    /* Troubleshooting code for different strings that should be the same
                    for (let j=0;j<oldSourcePage.length;j++) {
                        if (oldSourcePage.charCodeAt(j) != newSourcePage.charCodeAt(j)) {
                            console.log(`Character code is different at: ${j}`);
                            console.log(`Old Page Has: ${oldSourcePage.charAt(j)}`);
                            console.log(`New Page Has: ${newSourcePage.charAt(j)}`)
                            break;
                        }
                    }
                    console.log(oldSourcePage.length);
                    console.log(oldSourcePage);
                    console.log(newSourcePage.length);
                    console.log(newSourcePage.charCodeAt(newSourcePage.length-1))
                    console.log(newSourcePage);
                    wikiTableOutput.textContent = oldSourcePage;
                                        */
                    if (oldSourcePage != newSourcePage) {
                        dataChanged = true;
                    }
                } else {
                    updateSuccess = false;
                    console.warn(`Cannot update page: ${pageName}. ${sourcePullResult.error}`)
                }

                if (updateSuccess) {
                    if (dataChanged) {
                        let autoGeneratedPage = createItemPageContent(i);
                        let versionModifiedNew = newItemPage.replace(OLDVERSIONREGEX, VERSIONTEMPLATE);
                        //Try to fix the linebreak problem
                        if (autoGeneratedPage != versionModifiedNew) {
                            let lineBreakAdded = versionModifiedNew.replace(ITEMTEMPLATEREGEX, fillItemTemplate(i) + '\n')
                            if (lineBreakAdded == autoGeneratedPage) {
                                versionModifiedNew = lineBreakAdded;
                                console.log(`Adding Linebreak To Page: ${pageName} to fix generic difference.`)
                            }
                        }
                        /*
                        console.log(autoGeneratedPage.length);
                        console.log(versionModifiedNew.length);
                        for (let j = 0; j < versionModifiedNew.length; j++) {
                            if (autoGeneratedPage.charCodeAt(j) != versionModifiedNew.charCodeAt(j)) {
                                console.log(`Character code is different at: ${j}`);
                                console.log(`Gen Page Has: "${autoGeneratedPage.charAt(j)}" : ${autoGeneratedPage.charCodeAt(j)}`);
                                console.log(`New Page Has: "${versionModifiedNew.charAt(j)}" : ${versionModifiedNew.charCodeAt(j)}`)
                                console.log(autoGeneratedPage.slice(j))
                                console.log(versionModifiedNew.slice(j))
                                break;
                            }
                        }
                        */
                        if (autoGeneratedPage == versionModifiedNew) {
                            console.log(`Page: ${pageName}: Data Changed, but matches generic. Updating Version`);
                            pagesToEdit.push({ name: pageName, content: versionModifiedNew });
                        } else {
                            console.log(`Page: ${pageName}: Data Changed, but does not match generic. Manual Review Required.`);
                            pagesToEdit.push({ name: pageName, content: newItemPage });
                        }
                    } else {
                        newItemPage = newItemPage.replace(OLDVERSIONREGEX, VERSIONTEMPLATE);
                        console.log(`Page: ${pageName}: No Changes To Data, Updating Version`);
                        pagesToEdit.push({ name: pageName, content: newItemPage })
                    }
                }
            } else {
                console.warn(`Cannot update page: ${pageName}. ${pullResult.error}.`)
            }
        }
        let numChanged = pagesToEdit.length;
        console.log(`${numChanged} Pages changed and ready to update.`);
        if (numChanged > 0) {
            //console.log('Pushing updates to wiki (but not really)')
            bulkEditPages(pagesToEdit, 'Automatic update of Item Page')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function updateMonsterPageTemplates() {
    if (wikiDataLoaded) {
        let pagesToEdit = [];
        let numChanged = 0;
        for (let i = 0; i < MONSTERS.length; i++) {
            let pageName = wikiPageNames.monsters[i];
            let pullResult = await getFullWikiPage(pageName, 0);
            if (pullResult.success) {
                let oldItemPage = pullResult.text;
                let newItemPage = oldItemPage.replace(MONSTERTEMPLATEREGEX, fillMonsterTemplate(i));
                if (oldItemPage == newItemPage) {
                    newItemPage = oldItemPage.replace(OLDVERSIONREGEX, VERSIONTEMPLATE);
                    if (oldItemPage == newItemPage) {
                        console.log(`Page: ${pageName}: No Changes`);
                    } else {
                        console.log(`Page: ${pageName}: No Template Changes, Auto Updating Version`);
                        pagesToEdit.push({ name: pageName, content: newItemPage })
                        numChanged++;
                    }
                } else {
                    console.log(`Page: ${pageName}: Monster Template Changed`);
                    pagesToEdit.push({ name: pageName, content: newItemPage })
                    numChanged++;
                }
            } else {
                console.warn(`Cannot update page: ${pageName}. ${pullResult.error}.`)
            }
        }
        console.log(`${numChanged} Pages changed and ready to update.`);
        if (numChanged > 0) {
            console.log(pagesToEdit);
            bulkEditPages(pagesToEdit, 'Automatic update of Monster Page.')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function updateDungeonPageTemplates() {
    if (wikiDataLoaded) {
        let pagesToEdit = [];
        let numChanged = 0;
        for (let i = 0; i < DUNGEONS.length; i++) {
            let pageName = wikiPageNames.dungeons[i];
            let pullResult = await getFullWikiPage(pageName, 0);
            if (pullResult.success) {
                let oldItemPage = pullResult.text;
                let newItemPage = oldItemPage.replace(DUNGEONTEMPLATEREGEX, fillDungeonTemplate(i));
                if (oldItemPage == newItemPage) {
                    newItemPage = oldItemPage.replace(OLDVERSIONREGEX, VERSIONTEMPLATE);
                    if (oldItemPage == newItemPage) {
                        console.log(`Page: ${pageName}: No Changes`);
                    } else {
                        console.log(`Page: ${pageName}: No Template Changes, Auto Updating Version`);
                        pagesToEdit.push({ name: pageName, content: newItemPage })
                        numChanged++;
                    }
                } else {
                    let versionReplacedPage = newItemPage.replace(OLDVERSIONREGEX, VERSIONTEMPLATE);
                    if (versionReplacedPage == createDungeonPageContent(i)) {
                        console.log(`Page: ${pageName}: Dungeon Template Changed, But page is same as Default`);
                        pagesToEdit.push({ name: pageName, content: versionReplacedPage })
                    } else {
                        console.log(`Page: ${pageName}: Dungeon Template Changed, User Data may be inaccurate`);
                        pagesToEdit.push({ name: pageName, content: newItemPage })
                    }
                    numChanged++;
                }
            } else {
                console.warn(`Cannot update page: ${pageName}. ${pullResult.error}.`)
            }
        }
        console.log(`${numChanged} Pages changed and ready to update.`);
        if (numChanged > 0) {
            console.log(pagesToEdit);
            bulkEditPages(pagesToEdit, 'Automatic update of Dungeon page.')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function updateUpgradePages() {
    await updatePageTemplates(tiers, 'axeUpgrades', UPGRADETEMPLATEREGEX, fillAxeUpgradeTemplate, i => createUpgradePageContent(fillAxeUpgradeTemplate(i)), 1);
    await updatePageTemplates(tiers, 'pickUpgrades', UPGRADETEMPLATEREGEX, fillPickUpgradeTemplate, i => createUpgradePageContent(fillPickUpgradeTemplate(i)), 1);
    await updatePageTemplates(tiers, 'rodUpgrades', UPGRADETEMPLATEREGEX, fillRodUpgradeTemplate, i => createUpgradePageContent(fillRodUpgradeTemplate(i)), 1);
    await updatePageTemplates(cookingFireData, 'fireUpgrades', UPGRADETEMPLATEREGEX, fillFireUpgradeTemplate, i => createUpgradePageContent(fillFireUpgradeTemplate(i)));
    await updatePageTemplates(autoEatData, 'eatUpgrades', UPGRADETEMPLATEREGEX, fillEatUpgradeTemplate, i => createUpgradePageContent(fillEatUpgradeTemplate(i)));
    await updatePageTemplates(godUpgradeData, 'godUpgrades', UPGRADETEMPLATEREGEX, fillGodUpgradeTemplate, i => createUpgradePageContent(fillGodUpgradeTemplate(i)));
}

function updateCombatAreaPageTemplates() {
    updatePageTemplates(combatAreas, 'combatAreas', COMBATAREATEMPLATEREGEX, fillCombatAreaTemplate, createCombatAreaPageContent);
}
function updateSlayerAreaPageTemplates() {
    updatePageTemplates(slayerAreas, 'slayerAreas', SLAYERAREATEMPLATEREGEX, fillSlayerAreaTemplate, createSlayerAreaPageContent);
}
function updatePrayerPageTemplates() {
    updatePageTemplates(PRAYER, 'prayers', PRAYERTEMPLATEREGEX, fillPrayerTemplate, createPrayerPageContent);
}
function updateSpellPageTemplates() {
    updatePageTemplates(SPELLS, 'spells', SPELLTEMPLATEREGEX, fillSpellTemplate, createSpellPageContent);
}
function updateThievingPageTemplates() {
    updatePageTemplates(thievingNPC, 'thievingTarget', THIEVINGTARGETREGEX, fillThievingTemplate, createThievingTargetPage)
}
function updateItemPageItemTemplates() {
    updatePageTemplates(items, 'items', ITEMTEMPLATEREGEX, fillItemTemplate, createItemPageContent)
}
async function updateWeaponPageStats() {
    if (wikiDataLoaded) {
        let pagesToEdit = [];
        let numChanged = 0;
        for (let i = 0; i < items.length; i++) {
            if (items[i].equipmentSlot === CONSTANTS.equipmentSlot.Weapon) {
                let pageName = wikiPageNames.items[i];
                let pullResult = await getFullWikiPage(pageName, 0);
                if (pullResult.success) {
                    let oldItemPage = pullResult.text;
                    let newItemPage = oldItemPage.replace(WEAPONSTATSREGEX, fillWeaponStatsTemplate(i));
                    if (oldItemPage == newItemPage) {
                        console.log(`Page: ${pageName}: No Changes`);
                    } else {
                        console.log(`Page: ${pageName}: Weapon Template Changed`);
                        pagesToEdit.push({ name: pageName, content: newItemPage })
                        numChanged++;
                    }
                } else {
                    console.warn(`Cannot update page: ${pageName}. ${pullResult.error}.`)
                }
            }
        }
        console.log(`${numChanged} Pages changed and ready to update.`);
        if (numChanged > 0) {
            bulkEditPages(pagesToEdit, 'Automatic update of Weapon template data.')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function updateArmourPageStats() {
    if (wikiDataLoaded) {
        let pagesToEdit = [];
        let numChanged = 0;
        for (let i = 0; i < items.length; i++) {
            if (items[i].equipmentSlot !== CONSTANTS.equipmentSlot.Weapon && items[i].equipmentSlot !== undefined) {
                let pageName = wikiPageNames.items[i];
                let pullResult = await getFullWikiPage(pageName, 0);
                if (pullResult.success) {
                    let oldItemPage = pullResult.text;
                    let newItemPage = oldItemPage.replace(ARMOURSTATSREGEX, fillArmourStatsTemplate(i));
                    if (oldItemPage == newItemPage) {
                        console.log(`Page: ${pageName}: No Changes`);
                    } else {
                        console.log(`Page: ${pageName}: Armour Template Changed`);
                        pagesToEdit.push({ name: pageName, content: newItemPage })
                        numChanged++;
                    }
                } else {
                    console.warn(`Cannot update page: ${pageName}. ${pullResult.error}.`)
                }
            }
        }
        console.log(`${numChanged} Pages changed and ready to update.`);
        if (numChanged > 0) {
            bulkEditPages(pagesToEdit, 'Automatic update of Armour template data.')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

function fixMonsterPageVersions() {
    fixPageVersions(MONSTERS, 'monsters', createMonsterPageContent)
}
function fixItemPageVersions() {
    fixPageVersions(items, 'items', createItemPageContent)
}

async function updatePageTemplates(pageArray, pageNameKey, templateRegex, templateGenerator, pageGenerator, startIndex = 0) {
    if (wikiDataLoaded) {
        let pagesToEdit = [];
        let numChanged = 0;
        for (let i = startIndex; i < pageArray.length; i++) {
            let pageName = wikiPageNames[pageNameKey][i];
            let pullResult = await getFullWikiPage(pageName, 0);
            if (pullResult.success) {
                let oldItemPage = pullResult.text;
                let newItemPage = oldItemPage.replace(templateRegex, templateGenerator(i));
                if (oldItemPage == newItemPage) {
                    newItemPage = oldItemPage.replace(OLDVERSIONREGEX, VERSIONTEMPLATE);
                    if (oldItemPage == newItemPage) {
                        console.log(`Page: ${pageName}: No Changes`);
                    } else {
                        console.log(`Page: ${pageName}: No Template Changes, Auto Updating Version`);
                        pagesToEdit.push({ name: pageName, content: newItemPage })
                        numChanged++;
                    }
                } else {
                    let versionReplacedPage = newItemPage.replace(OLDVERSIONREGEX, VERSIONTEMPLATE);
                    if (versionReplacedPage == pageGenerator(i)) {
                        console.log(`Page: ${pageName}: Template Changed, But page is same as Default`);
                        pagesToEdit.push({ name: pageName, content: versionReplacedPage })
                    } else {
                        console.log(`Page: ${pageName}: Template Changed, User Data may be inaccurate`);
                        pagesToEdit.push({ name: pageName, content: newItemPage })
                    }
                    numChanged++;
                }
            } else {
                console.warn(`Cannot update page: ${pageName}. ${pullResult.error}.`)
            }
        }
        console.log(`${numChanged} Pages changed and ready to update.`);
        if (numChanged > 0) {
            console.log(pagesToEdit);
            await bulkEditPages(pagesToEdit, `Automatic update of ${pageNameKey} page.`)
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function fixPageVersions(pageArray, pageNameKey, pageGenerator) {
    if (wikiDataLoaded) {
        let pagesToEdit = [];
        let numChanged = 0;
        for (let i = 0; i < pageArray.length; i++) {
            let pageName = wikiPageNames[pageNameKey][i];
            let pullResult = await getFullWikiPage(pageName, 0);
            if (pullResult.success) {
                let oldItemPage = pullResult.text;
                let newItemPage = oldItemPage.replace(OLDVERSIONREGEX, VERSIONTEMPLATE);
                if (newItemPage == pageGenerator(i)) {
                    if (oldItemPage == newItemPage) {
                        console.log(`Page: ${pageName}: is already up to date.`);
                    } else {
                        console.log(`Page: ${pageName}: matches generate, changing version`);
                        pagesToEdit.push({ name: pageName, content: newItemPage })
                        numChanged++;
                    }
                } else {
                    console.log(`Page: ${pageName}: Can't update version, still OOD`);
                }
            } else {
                console.warn(`Cannot update page: ${pageName}. ${pullResult.error}.`)
            }
        }
        console.log(`${numChanged} Pages changed and ready to update.`);
        if (numChanged > 0) {
            console.log(pagesToEdit);
            bulkEditPages(pagesToEdit, 'Automatic update of Combat Area page.')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}
async function rollBackBadSectionRemoval(pageTitle) {
    revisions = await getLastRevisions(pageTitle, 2);
    if (revisions[0].comment == 'Removal of old section.') {
        let firstID = revisions[0].revid;
        let secondID = revisions[1].revid;
        let token = await getCsrfToken();
        result = await undoLastEdit(pageTitle, token, firstID, secondID);
    }
    console.log(result);
}

async function fixBadItemPageEdits() {
    if (wikiDataLoaded) {
        for (let i = 0; i < items.length; i++) {
            let pageName = wikiPageNames.items[i];
            let revisions = await getLastRevisions(pageName, 2);
            if (revisions[0].comment == 'Removal of old section.' && revisions[1].comment == 'Removal of old section.') {
                let firstID = revisions[0].revid;
                let secondID = revisions[1].revid;
                let token = await getCsrfToken();
                result = await undoLastEdit(pageName, token, firstID, secondID);
                console.log('Undid bad Revision')
            }
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}
async function replaceOldItemVersionWithNew() {
    if (wikiDataLoaded) {
        let pagesToEdit = [];
        let numChanged = 0;
        for (let i = 0; i < items.length; i++) {
            let pageName = wikiPageNames['items'][i];
            let pullResult = await getFullWikiPage(pageName, 0);
            if (pullResult.success) {
                let oldItemPage = pullResult.text;
                let newItemPage = oldItemPage.replace(OLDVERSIONREGEX, VERSIONTEMPLATE);
                let previousVersionPage = createItemPageContentOld(i);
                if (newItemPage == previousVersionPage) {
                    console.log(`Page: ${pageName}: matches old generate, changing to new generate`);
                    pagesToEdit.push({ name: pageName, content: createItemPageContent(i) })
                    numChanged++;
                } else {
                    console.log(`Page: ${pageName}: Can't update page, still OOD`);
                }
            } else {
                console.warn(`Cannot update page: ${pageName}. ${pullResult.error}.`)
            }
        }
        console.log(`${numChanged} Pages changed and ready to update.`);
        if (numChanged > 0) {
            console.log(pagesToEdit);
            await bulkEditPages(pagesToEdit, 'Automatic update of Combat Area page.')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function updateSpecificSourceTemplates() {
    if (wikiDataLoaded) {
        let pagesToEdit = [];
        let numChanged = 0;
        for (let i = 0; i < items.length; i++) {
            if (items[i].isFishingSpecial || items[i].isJunk > 0) {
                let pageName = `Template:${items[i].name} Sources`;
                pagesToEdit.push({ name: pageName, content: createItemSourceTemplatePage(i) })
                numChanged++;
            }
        }
        if (numChanged > 0) {
            console.log(pagesToEdit);
            await bulkEditPages(pagesToEdit, 'Automatic Update of Item Source Template')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function setNonMatchingItemPagesToOldVersion() {
    if (wikiDataLoaded) {
        let pagesToEdit = [];
        let numChanged = 0;
        for (let i = 0; i < items.length; i++) {
            let pageName = wikiPageNames['items'][i];
            let pullResult = await getFullWikiPage(pageName, 0);
            if (pullResult.success) {
                let oldItemPage = pullResult.text;
                let newItemPage = oldItemPage.replace(/{{V0.14.2]}/, '{{V0.14.2}}');
                if (newItemPage !== oldItemPage) {
                    console.log(`Page: ${pageName}: fixing version typo`);
                    pagesToEdit.push({ name: pageName, content: newItemPage })
                    numChanged++;
                } else {
                    console.log(`Page: ${pageName}: We didn't fuck up`);
                }
            } else {
                console.warn(`Cannot update page: ${pageName}. ${pullResult.error}.`)
            }
        }
        console.log(`${numChanged} Pages changed and ready to update.`);
        if (numChanged > 0) {
            console.log(pagesToEdit);
            bulkEditPages(pagesToEdit, 'Automatic update of version typo.')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function addItemSourcesTemplateToBadVersions() {
    if (wikiDataLoaded) {
        let pagesToEdit = [];
        let numChanged = 0;
        for (let i = 0; i < items.length; i++) {
            let pageName = wikiPageNames['items'][i];
            let pullResult = await getFullWikiPage(pageName, 0);
            if (pullResult.success) {
                let oldItemPage = pullResult.text;
                if (oldItemPage.includes('{{V0.14.2}}')) {
                    let newString = createSection('Item Sources');;
                    newString += `{{${items[i].name} Sources}}`;
                    newString += '[[Category:Items]]';
                    let newItemPage = oldItemPage.replace(/\[\[Category:Items\]\]/, newString);
                    console.log(`Page: ${pageName}: Adding Item Source section`);
                    pagesToEdit.push({ name: pageName, content: newItemPage })
                    numChanged++;
                }
            } else {
                console.warn(`Cannot update page: ${pageName}. ${pullResult.error}.`)
            }
        }
        console.log(`${numChanged} Pages changed and ready to update.`);
        if (numChanged > 0) {
            console.log(pagesToEdit);
            bulkEditPages(pagesToEdit, 'Automatic update of version typo.')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function removeOldSectionsIfOnlyTemplates() {
    if (wikiDataLoaded) {
        let pageData = [];
        for (let i = 0; i < items.length; i++) {
            let pageName = wikiPageNames.items[i];
            let sectionIDs = await getSectionIDs(pageName, 'Loot Sources');
            if (sectionIDs.length != 0) {
                let sectionContent = await getWikiPageSection(pageName, sectionIDs[0]);
                let newSectionContent = sectionContent.replace(TABLEREGEX, '');
                if (newSectionContent == '==Loot Sources==\n') {
                    pageData.push({ name: pageName, content: '', section: sectionIDs[0] })
                }
            }
        }
        if (pageData.length > 0) {
            console.log(`${pageData.length} Section ready to remove.`);
            console.log(pageData);
            await bulkEditPageSections(pageData, `Removal of old section.`)
        } else {
            console.log('No sections to remove.')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function changeChestTablesToTemplates() {
    if (wikiDataLoaded) {
        let pageData = [];
        for (let i = 0; i < items.length; i++) {
            if (items[i].canOpen) {
                let pageName = wikiPageNames.items[i];
                let sectionIDs = await getSectionIDs(pageName, 'Loot Table');
                if (sectionIDs.length != 0) {
                    let sectionContent = await getWikiPageSection(pageName, sectionIDs[0]);
                    let newSectionContent = sectionContent.replace(TABLEREGEX, `{{${items[i].name}LootTable}}\n`);
                    if (newSectionContent != sectionContent) {
                        pageData.push({ name: pageName, content: newSectionContent, section: sectionIDs[0] })
                    }
                }
            }
        }
        if (pageData.length > 0) {
            console.log(`${pageData.length} Section ready to change.`);
            console.log(pageData);
            await bulkEditPageSections(pageData, `Removal of old section.`)
        } else {
            console.log('No sections to remove.')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function changeKnifeJavelinTemplates() {
    if (wikiDataLoaded) {
        let pagesToEdit = [];
        let numChanged = 0;
        for (let i = 0; i < items.length; i++) {
            if (items[i].equipmentSlot == CONSTANTS.equipmentSlot.Quiver && (items[i].ammoType == 2 || items[i].ammoType == 3)) {
                let pageName = wikiPageNames.items[i];
                let pullResult = await getFullWikiPage(pageName, 0);
                if (pullResult.success) {
                    let oldItemPage = pullResult.text;
                    let newItemPage = oldItemPage.replace(ARMOURSTATSREGEX, fillWeaponStatsTemplate(i));
                    if (oldItemPage != newItemPage) {
                        pagesToEdit.push({ name: pageName, content: newItemPage });
                        numChanged++;
                    }
                } else {
                    console.warn(`Cannot update page: ${pageName}. ${pullResult.error}.`)
                }
            }
        }
        console.log(`${numChanged} Pages changed and ready to update.`);
        if (numChanged > 0) {
            console.log(pagesToEdit);
            bulkEditPages(pagesToEdit, 'Changed Armour Template to Weapon Template')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function removeOldSections() {
    await removeItemPageSections('Item Creation');
    await removeItemPageSections('Loot Sources');
}
async function removeItemPageSections(sectionName) {
    if (wikiDataLoaded) {
        let pageData = [];
        for (let i = 2; i < 3; i++) {
            let pageName = wikiPageNames.items[i];
            let sectionIDs = await getSectionIDs(pageName, sectionName);
            if (sectionIDs.length != 0) {
                pageData.push({ name: pageName, content: '', section: sectionIDs[0] })
            }
        }
        if (pageData.length > 0) {
            console.log(`${pageData.length} Section ready to remove.`);
            console.log(pageData);
            await bulkEditPageSections(pageData, `Removal of old section.`)
        } else {
            console.log('No sections to remove.')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function addItemSourceSections() {
    if (wikiDataLoaded) {
        let pageData = [];
        for (let i = 0; i < items.length; i += 10) {
            let pageName = wikiPageNames.items[i];
            let pageSections = await getPageSections(pageName);

            if (sectionIDs.length != 0) {
                pageData.push({ name: pageName, content: '', section: sectionIDs[0] })
            } else {

            }
        }
        if (pageData.length > 0) {
            console.log(`${pageData.length} Section ready to remove.`);
            console.log(pageData);
            await bulkEditPageSections(pageData, `Removal of old section.`)
        } else {
            console.log('No sections to remove.')
        }
    } else {
        console.error('Wiki data is not loaded.');
    }
}

async function manualVersionReview(version) {
    oldVersionReview.pages = await getCategoryPageMembers(version);
    console.log(oldVersionReview.pages)
    oldVersionReview.currentPage = 0;
    oldVersionReview.updatePage = [];
    oldVersionReview.titleElement.textContent = oldVersionReview.pages[oldVersionReview.currentPage].title;
    oldVersionReview.currentPageContent = (await getFullWikiPage(oldVersionReview.pages[oldVersionReview.currentPage].title)).text;
    oldVersionReview.outputField.textContent = oldVersionReview.currentPageContent;
    oldVersionReview.panel.style.display = '';
}

function updateVersion() {
    oldVersionReview.updatePages.push(
        { name: oldVersionReview.pages[oldVersionReview.currentPage].title, content: oldVersionReview.currentPageContent.replace(OLDVERSIONREGEX, VERSIONTEMPLATE) }
    )
    proceedToNextPage();
}

async function proceedToNextPage() {
    oldVersionReview.currentPage++;
    if (oldVersionReview.pages.length > oldVersionReview.currentPage) {
        oldVersionReview.titleElement.textContent = oldVersionReview.pages[oldVersionReview.currentPage].title;
        oldVersionReview.currentPageContent = (await getFullWikiPage(oldVersionReview.pages[oldVersionReview.currentPage].title)).text;
        oldVersionReview.outputField.textContent = oldVersionReview.currentPageContent;
    } else {
        console.log(oldVersionReview.updatePages);
        bulkEditPages(oldVersionReview.updatePages,'Manual Review: No Changes. Updating Version.')
        oldVersionReview.panel.style.display = 'none';
    }
}